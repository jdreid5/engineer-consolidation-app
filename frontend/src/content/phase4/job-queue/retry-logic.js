export const retryLogic = { title: "Retry Logic & Error Handling", duration: "25 minutes", content: "## Configuring Bull Retries\n\n```javascript\nqueue.add(jobData, {\n  attempts: 5,\n  backoff: {\n    type: 'exponential',\n    delay: 1000  // 1s, 2s, 4s, 8s, 16s\n  }\n});\n```\n\n## Custom Retry Logic\n\n```javascript\nclass RetryStrategy {\n  static exponential(attempt, baseDelay = 1000) {\n    return Math.pow(2, attempt) * baseDelay;\n  }\n  \n  static exponentialWithJitter(attempt, baseDelay = 1000) {\n    const exp = Math.pow(2, attempt) * baseDelay;\n    const jitter = Math.random() * 1000;\n    return exp + jitter;\n  }\n  \n  static linear(attempt, delay = 5000) {\n    return delay * attempt;\n  }\n}\n```\n\n## Error Classification\n\n```javascript\nclass JobError extends Error {\n  constructor(message, isRetryable = true) {\n    super(message);\n    this.isRetryable = isRetryable;\n  }\n}\n\n// In processor\ntry {\n  await processJob(job);\n} catch (error) {\n  if (error.isRetryable) {\n    throw error; // Bull will retry\n  } else {\n    // Permanent failure - don't retry\n    job.markFailed(error.message);\n    await jobRepository.save(job);\n    // Don't rethrow\n  }\n}\n```\n\n## Dead Letter Queue\n\n```javascript\n// After all retries exhausted\nqueue.on('failed', async (bullJob, error) => {\n  if (bullJob.attemptsMade >= bullJob.opts.attempts) {\n    // Move to dead letter queue for manual review\n    await deadLetterQueue.add({\n      originalJob: bullJob.data,\n      error: error.message,\n      failedAt: new Date()\n    });\n  }\n});\n```", quiz: [{ question: "Why add jitter to exponential backoff?", options: ["For security", "To prevent thundering herd when many jobs fail together", "For logging", "Redis requires it"], correctAnswer: 1, explanation: "Without jitter, many jobs that failed at the same time would all retry simultaneously, potentially overwhelming the service again." }] };



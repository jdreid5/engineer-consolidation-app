export const testingDeployment = { title: "Testing & Deployment", duration: "30 minutes", content: "## Unit Testing\n\n```javascript\ndescribe('Job', () => {\n  test('creates with pending status', () => {\n    const job = Job.create({ type: 'email', payload: {}, userId: '1' });\n    expect(job.status).toBe('pending');\n    expect(job.attempts).toBe(0);\n  });\n  \n  test('increments attempts', () => {\n    const job = Job.create({ type: 'email', payload: {}, userId: '1' });\n    job.incrementAttempts();\n    expect(job.attempts).toBe(1);\n  });\n});\n```\n\n## Integration Testing\n\n```javascript\ndescribe('POST /jobs', () => {\n  test('creates a job', async () => {\n    const response = await request(app)\n      .post('/jobs')\n      .set('Authorization', `Bearer ${token}`)\n      .send({ type: 'email', payload: { to: 'test@test.com' } })\n      .expect(201);\n    \n    expect(response.body.id).toBeDefined();\n    expect(response.body.status).toBe('pending');\n  });\n});\n```\n\n## Testing Workers\n\n```javascript\ntest('processes email job', async () => {\n  const mockEmailService = { send: jest.fn().mockResolvedValue(true) };\n  const job = Job.create({ type: 'email', payload: { to: 'test@test.com' }, userId: '1' });\n  \n  await emailProcessor(job, { emailService: mockEmailService });\n  \n  expect(mockEmailService.send).toHaveBeenCalledWith({ to: 'test@test.com' });\n});\n```\n\n## Deployment Checklist\n\n- [ ] Environment variables set\n- [ ] Redis accessible\n- [ ] Database migrations run\n- [ ] Health check endpoint works\n- [ ] Logging configured\n- [ ] Workers scaled appropriately\n- [ ] Monitoring/alerts set up\n\n## Docker Compose Example\n\n```yaml\nversion: '3'\nservices:\n  api:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - REDIS_HOST=redis\n    depends_on:\n      - redis\n  \n  worker:\n    build: .\n    command: node src/workers/index.js\n    environment:\n      - REDIS_HOST=redis\n    depends_on:\n      - redis\n  \n  redis:\n    image: redis:alpine\n```\n\n## Congratulations!\n\nYou've built a production-quality job queue system! ðŸŽ‰", quiz: [{ question: "Why run workers as separate processes from the API?", options: ["It's simpler", "They can scale independently and a worker crash doesn't affect the API", "It's required by Redis", "For security"], correctAnswer: 1, explanation: "Separate processes allow independent scaling (more workers during high load) and isolation (worker crash doesn't bring down the API)." }] };



export const workersProcessing = { title: "Workers & Job Processing", duration: "30 minutes", content: "## Worker Implementation\n\n```javascript\n// src/workers/emailWorker.js\nclass EmailWorker {\n  constructor(queueService, jobRepository, emailService) {\n    this.queueService = queueService;\n    this.jobRepository = jobRepository;\n    this.emailService = emailService;\n  }\n  \n  start() {\n    const queue = this.queueService.getQueue('email');\n    \n    queue.process(async (bullJob) => {\n      const { jobId } = bullJob.data;\n      const job = await this.jobRepository.findById(jobId);\n      \n      job.markProcessing();\n      job.incrementAttempts();\n      await this.jobRepository.save(job);\n      \n      try {\n        await this.emailService.send(job.payload);\n        job.markComplete();\n      } catch (error) {\n        job.markFailed(error.message);\n        throw error; // Bull will retry\n      } finally {\n        await this.jobRepository.save(job);\n      }\n    });\n    \n    console.log('Email worker started');\n  }\n}\n```\n\n## Strategy Pattern for Job Types\n\n```javascript\n// src/workers/processors/index.js\nconst processors = {\n  email: async (job, services) => {\n    await services.emailService.send(job.payload);\n  },\n  notification: async (job, services) => {\n    await services.notificationService.push(job.payload);\n  },\n  report: async (job, services) => {\n    await services.reportService.generate(job.payload);\n  }\n};\n\n// Generic worker using strategy\nclass GenericWorker {\n  constructor(queueName, processor, services) {\n    this.queueName = queueName;\n    this.processor = processor;\n    this.services = services;\n  }\n  \n  async process(job) {\n    await this.processor(job, this.services);\n  }\n}\n```\n\n## Running Workers\n\n```javascript\n// src/workers/index.js\nconst workers = [\n  new EmailWorker(queueService, jobRepo, emailService),\n  new NotificationWorker(queueService, jobRepo, notifService)\n];\n\nworkers.forEach(w => w.start());\n```", quiz: [{ question: "Why use the Strategy pattern for different job types?", options: ["It's faster", "Each job type can have different processing logic without changing the worker structure", "It uses less memory", "Redis requires it"], correctAnswer: 1, explanation: "Strategy pattern allows different processing logic per job type while keeping the worker framework consistent and extensible." }] };



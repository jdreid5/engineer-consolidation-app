export const settingUp = { title: "Setting Up the Project", duration: "25 minutes", content: "## Project Structure\n\n```\njob-queue/\n├── src/\n│   ├── api/\n│   │   ├── controllers/\n│   │   ├── middleware/\n│   │   └── routes/\n│   ├── application/\n│   │   └── useCases/\n│   ├── domain/\n│   │   ├── entities/\n│   │   └── repositories/\n│   ├── infrastructure/\n│   │   ├── database/\n│   │   ├── queue/\n│   │   └── config/\n│   └── workers/\n├── tests/\n├── package.json\n└── README.md\n```\n\n## Initial Setup\n\n```bash\nmkdir job-queue && cd job-queue\nnpm init -y\nnpm install express bull ioredis better-sqlite3 bcryptjs jsonwebtoken dotenv\nnpm install -D jest nodemon\n```\n\n## Configuration\n\n```javascript\n// src/infrastructure/config/index.js\nrequire('dotenv').config();\n\nmodule.exports = {\n  port: process.env.PORT || 3000,\n  jwtSecret: process.env.JWT_SECRET || 'dev-secret',\n  redis: {\n    host: process.env.REDIS_HOST || 'localhost',\n    port: process.env.REDIS_PORT || 6379\n  }\n};\n```\n\n## Entry Point\n\n```javascript\n// src/index.js\nconst express = require('express');\nconst config = require('./infrastructure/config');\n\nconst app = express();\napp.use(express.json());\n\napp.get('/health', (req, res) => {\n  res.json({ status: 'ok' });\n});\n\napp.listen(config.port, () => {\n  console.log(`Server running on port ${config.port}`);\n});\n```", quiz: [{ question: "Why separate code into layers (api, application, domain, infrastructure)?", options: ["It's required by Express", "To keep concerns separated and code maintainable", "To use more files", "For performance"], correctAnswer: 1, explanation: "Layered architecture separates concerns, making code easier to understand, test, and modify independently." }] };



export const buildingAuth = { title: "Building Authentication", duration: "30 minutes", content: "## User Entity\n\n```javascript\n// src/domain/entities/User.js\nclass User {\n  constructor({ id, email, passwordHash, createdAt }) {\n    this.id = id;\n    this.email = email;\n    this.passwordHash = passwordHash;\n    this.createdAt = createdAt || new Date();\n  }\n  \n  static create({ email, passwordHash }) {\n    return new User({\n      id: generateId(),\n      email,\n      passwordHash\n    });\n  }\n}\n```\n\n## Auth Service\n\n```javascript\n// src/application/useCases/AuthService.js\nclass AuthService {\n  constructor(userRepository, passwordHasher, tokenService) {\n    this.userRepository = userRepository;\n    this.passwordHasher = passwordHasher;\n    this.tokenService = tokenService;\n  }\n  \n  async register({ email, password }) {\n    const existing = await this.userRepository.findByEmail(email);\n    if (existing) throw new Error('Email already registered');\n    \n    const hash = await this.passwordHasher.hash(password);\n    const user = User.create({ email, passwordHash: hash });\n    await this.userRepository.save(user);\n    \n    return { user, token: this.tokenService.generate(user) };\n  }\n  \n  async login({ email, password }) {\n    const user = await this.userRepository.findByEmail(email);\n    if (!user) throw new Error('Invalid credentials');\n    \n    const valid = await this.passwordHasher.verify(password, user.passwordHash);\n    if (!valid) throw new Error('Invalid credentials');\n    \n    return { user, token: this.tokenService.generate(user) };\n  }\n}\n```\n\n## Auth Middleware\n\n```javascript\n// src/api/middleware/auth.js\nfunction authMiddleware(tokenService) {\n  return (req, res, next) => {\n    const token = req.headers.authorization?.split(' ')[1];\n    if (!token) return res.status(401).json({ error: 'No token' });\n    \n    try {\n      req.user = tokenService.verify(token);\n      next();\n    } catch {\n      res.status(401).json({ error: 'Invalid token' });\n    }\n  };\n}\n```", quiz: [{ question: "Why inject passwordHasher instead of using bcrypt directly?", options: ["For performance", "To allow testing with a mock hasher and swapping implementations", "It's required by Express", "To use less memory"], correctAnswer: 1, explanation: "Dependency injection allows testing without slow bcrypt operations and makes it easy to swap implementations (e.g., argon2)." }] };



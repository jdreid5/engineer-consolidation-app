export const findingPatterns = { title: "Finding Structure & Patterns", duration: "25 minutes", content: "Learning to recognize patterns accelerates code comprehension.\n\n## Common Architectural Patterns\n\n### MVC (Model-View-Controller)\n```\nmodels/     → Data and business logic\nviews/      → Presentation/templates\ncontrollers/ → Handle requests, coordinate\n```\n\n### Layered Architecture\n```\npresentation/  → HTTP, UI\napplication/   → Use cases\ndomain/        → Business rules\ninfrastructure/ → Database, external services\n```\n\n### Microservices\n```\nuser-service/\norder-service/\npayment-service/\ngateway/\n```\n\n## Code-Level Patterns to Recognize\n\n### Repository Pattern\n```javascript\n// Look for classes with methods like:\nfindById(id)\nfindAll()\nsave(entity)\ndelete(id)\n```\n\n### Factory Pattern\n```javascript\n// Look for static create methods:\nstatic create(type)\nstatic fromJSON(data)\n```\n\n### Observer/Events\n```javascript\n// Look for:\nemitter.on('event', handler)\nemitter.emit('event', data)\n```\n\n## Finding Conventions\n\n### Naming Patterns\n- `*Controller` - HTTP handlers\n- `*Service` - Business logic\n- `*Repository` - Data access\n- `*DTO` - Data transfer objects\n- `*Util` - Helpers\n\n### File Organization\n- One class per file?\n- Grouped by feature or layer?\n- Test files next to source or separate folder?\n\n## Questions to Ask\n1. Where does validation happen?\n2. How are errors handled?\n3. Where is authentication checked?\n4. How is configuration loaded?\n5. What's the testing strategy?", quiz: [{ question: "What naming convention often indicates data access code?", options: ["*Controller", "*Repository", "*Service", "*Helper"], correctAnswer: 1, explanation: "Repository classes typically handle data persistence (CRUD operations). They abstract the database from the rest of the application." }] };



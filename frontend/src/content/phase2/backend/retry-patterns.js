export const retryPatterns = { title: "Retry Patterns & Idempotency", duration: "25 minutes", content: "## Retry Strategies\n\n### Exponential Backoff\n```javascript\nasync function withRetry(fn, maxRetries = 3) {\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await fn();\n    } catch (error) {\n      if (i === maxRetries - 1) throw error;\n      const delay = Math.pow(2, i) * 1000; // 1s, 2s, 4s\n      await sleep(delay);\n    }\n  }\n}\n```\n\n### With Jitter\nAdd randomness to prevent thundering herd:\n```javascript\nconst delay = Math.pow(2, i) * 1000 + Math.random() * 1000;\n```\n\n## Idempotency\n\nAn operation is idempotent if repeating it has the same effect as doing it once.\n\n```javascript\n// NOT idempotent - creates duplicate\nPOST /orders { items: [...] }\n\n// Idempotent - same key = same result\nPOST /orders\nIdempotency-Key: abc123\n{ items: [...] }\n\n// Server checks key, returns existing result if seen before\nasync function createOrder(req, res) {\n  const key = req.headers['idempotency-key'];\n  const existing = await cache.get(`idempotency:${key}`);\n  if (existing) return res.json(existing);\n  \n  const order = await db.createOrder(req.body);\n  await cache.set(`idempotency:${key}`, order, '24h');\n  res.status(201).json(order);\n}\n```\n\n## When to Retry\n- Network timeouts\n- 5xx server errors\n- Rate limiting (429)\n\n## When NOT to Retry\n- 4xx client errors (bad request)\n- Authentication failures\n- Business logic errors", quiz: [{ question: "Why add jitter to retry delays?", options: ["Faster retries", "Prevent many clients retrying at the same time", "Use less memory", "Better logging"], correctAnswer: 1, explanation: "Jitter adds randomness so that many clients that failed at the same time don't all retry together, which would overload the server again." }] };



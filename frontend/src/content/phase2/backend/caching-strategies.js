export const cachingStrategies = { title: "Caching Strategies", duration: "20 minutes", content: "Caching stores data for faster subsequent access.\n\n## Cache-Aside (Lazy Loading)\n```javascript\nasync function getUser(id) {\n  let user = await cache.get(`user:${id}`);\n  if (!user) {\n    user = await db.findUser(id);\n    await cache.set(`user:${id}`, user, '1h');\n  }\n  return user;\n}\n```\n\n## Write-Through\n```javascript\nasync function updateUser(id, data) {\n  const user = await db.updateUser(id, data);\n  await cache.set(`user:${id}`, user);  // Always update cache\n  return user;\n}\n```\n\n## Cache Invalidation\nThe hardest problem in CS!\n\n```javascript\n// Time-based expiration\ncache.set('key', value, { ttl: 3600 });\n\n// Event-based invalidation\nasync function updateUser(id, data) {\n  await db.updateUser(id, data);\n  await cache.delete(`user:${id}`);\n}\n```\n\n## HTTP Caching\n```javascript\nres.set('Cache-Control', 'public, max-age=3600');\nres.set('ETag', 'abc123');\n```", quiz: [{ question: "What is the 'cache-aside' pattern?", options: ["Cache before database always", "Check cache first, load from DB on miss", "Never cache data", "Cache only writes"], correctAnswer: 1, explanation: "Cache-aside checks the cache first. On miss, it loads from the database and populates the cache for future requests." }] };



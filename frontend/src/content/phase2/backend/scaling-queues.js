export const scalingQueues = { title: "Scaling & Message Queues", duration: "25 minutes", content: "## Scaling Types\n\n### Vertical Scaling\nBigger machine (more CPU, RAM)\n- Simple\n- Limited ceiling\n\n### Horizontal Scaling\nMore machines\n- Virtually unlimited\n- Requires stateless design\n\n## Message Queues\n\nDecouple producers from consumers:\n\n```\nWeb Server → [Queue] → Worker\n              │\n              └────→ Worker\n```\n\n### Why Queues?\n- Handle traffic spikes\n- Retry failed jobs\n- Scale workers independently\n- Async processing\n\n### Example with Bull (Node.js)\n```javascript\nconst Queue = require('bull');\nconst emailQueue = new Queue('emails');\n\n// Producer\nawait emailQueue.add({ to: 'user@example.com', subject: 'Hello' });\n\n// Consumer\nemailQueue.process(async (job) => {\n  await sendEmail(job.data);\n});\n```\n\n### Common Use Cases\n- Sending emails/notifications\n- Image/video processing\n- Report generation\n- Data sync between services", quiz: [{ question: "What is the main benefit of message queues?", options: ["Faster execution", "Decoupling producers and consumers for reliability and scalability", "Less code", "Better security"], correctAnswer: 1, explanation: "Queues decouple producers from consumers, allowing independent scaling, handling failures gracefully, and smoothing traffic spikes." }] };



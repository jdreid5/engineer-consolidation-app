export const authentication = { title: "Authentication Deep Dive", duration: "30 minutes", content: "Authentication verifies identity. Authorization determines permissions.\n\n## Common Methods\n\n### Session-Based\n```javascript\n// Login\napp.post('/login', (req, res) => {\n  const user = authenticate(req.body);\n  req.session.userId = user.id;  // Store in session\n  res.json({ success: true });\n});\n\n// Protected route\napp.get('/profile', (req, res) => {\n  if (!req.session.userId) return res.status(401).json({ error: 'Not authenticated' });\n  // ...\n});\n```\n\n### Token-Based (JWT)\n```javascript\nconst jwt = require('jsonwebtoken');\n\n// Login - return token\napp.post('/login', (req, res) => {\n  const user = authenticate(req.body);\n  const token = jwt.sign({ userId: user.id }, SECRET, { expiresIn: '1h' });\n  res.json({ token });\n});\n\n// Verify token middleware\nfunction authMiddleware(req, res, next) {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    req.user = jwt.verify(token, SECRET);\n    next();\n  } catch {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n}\n```\n\n## Security Best Practices\n- Hash passwords with bcrypt (cost factor 10+)\n- Use HTTPS always\n- Set secure cookie flags\n- Implement rate limiting\n- Store tokens securely (httpOnly cookies)", quiz: [{ question: "Why use bcrypt for passwords instead of SHA256?", options: ["It's faster", "It's designed to be slow, making brute force attacks harder", "It produces shorter hashes", "It's reversible"], correctAnswer: 1, explanation: "bcrypt is intentionally slow (configurable work factor), making brute force attacks expensive. Fast hashes like SHA256 allow millions of attempts per second." }] };



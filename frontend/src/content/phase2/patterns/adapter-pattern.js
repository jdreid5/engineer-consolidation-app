export const adapterPattern = { title: "Adapter Pattern", duration: "15 minutes", content: "The Adapter pattern allows incompatible interfaces to work together.\n\n```javascript\n// Old analytics library\nclass OldAnalytics {\n  track(eventName, data) {\n    console.log('Old:', eventName, data);\n  }\n}\n\n// New analytics library with different interface\nclass NewAnalytics {\n  logEvent(event) {\n    console.log('New:', event.name, event.properties);\n  }\n}\n\n// Adapter makes NewAnalytics look like OldAnalytics\nclass AnalyticsAdapter {\n  constructor(newAnalytics) {\n    this.newAnalytics = newAnalytics;\n  }\n  \n  track(eventName, data) {\n    this.newAnalytics.logEvent({\n      name: eventName,\n      properties: data\n    });\n  }\n}\n\n// Usage - existing code doesn't need to change\nconst analytics = new AnalyticsAdapter(new NewAnalytics());\nanalytics.track('page_view', { url: '/home' });\n```", quiz: [{ question: "When is the Adapter pattern most useful?", options: ["When creating new objects", "When integrating code with incompatible interfaces", "When caching data", "When implementing undo"], correctAnswer: 1, explanation: "Adapter is useful when you need to use existing code that has an incompatible interface, like integrating a new library with legacy code." }] };



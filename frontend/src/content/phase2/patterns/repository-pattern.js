export const repositoryPattern = { title: "Repository Pattern", duration: "20 minutes", content: "The Repository pattern mediates between the domain and data mapping layers, providing a collection-like interface for accessing domain objects.\n\n```javascript\n// Repository interface\nclass UserRepository {\n  async findById(id) { throw new Error('Not implemented'); }\n  async findByEmail(email) { throw new Error('Not implemented'); }\n  async save(user) { throw new Error('Not implemented'); }\n  async delete(id) { throw new Error('Not implemented'); }\n}\n\n// Concrete implementation\nclass PostgresUserRepository extends UserRepository {\n  constructor(db) { super(); this.db = db; }\n  \n  async findById(id) {\n    const result = await this.db.query('SELECT * FROM users WHERE id = $1', [id]);\n    return result.rows[0] ? this.toEntity(result.rows[0]) : null;\n  }\n  \n  async save(user) {\n    await this.db.query(\n      'INSERT INTO users (id, email, name) VALUES ($1, $2, $3) ON CONFLICT (id) DO UPDATE SET email = $2, name = $3',\n      [user.id, user.email, user.name]\n    );\n  }\n  \n  toEntity(row) {\n    return new User({ id: row.id, email: row.email, name: row.name });\n  }\n}\n```\n\n## Benefits\n- Domain layer doesn't know about persistence\n- Easy to swap implementations (PostgreSQL to MongoDB)\n- Testable with in-memory implementations", quiz: [{ question: "What does the Repository pattern abstract away?", options: ["Business logic", "Data persistence details", "User interface", "Network communication"], correctAnswer: 1, explanation: "Repository provides a collection-like interface to domain objects, hiding how data is stored and retrieved from the domain layer." }] };



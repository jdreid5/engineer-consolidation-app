export const dependencyInjection = { title: "Dependency Injection", duration: "20 minutes", content: "Dependency Injection (DI) passes dependencies to a class rather than having it create them. It's the most important pattern for writing testable, flexible code.\n\n```javascript\n// Without DI - hard to test\nclass OrderService {\n  constructor() {\n    this.db = new PostgresDatabase(); // Hardcoded!\n    this.mailer = new SMTPMailer();   // Hardcoded!\n  }\n}\n\n// With DI - flexible and testable\nclass OrderService {\n  constructor(db, mailer) {\n    this.db = db;\n    this.mailer = mailer;\n  }\n}\n\n// Production\nconst service = new OrderService(\n  new PostgresDatabase(),\n  new SMTPMailer()\n);\n\n// Testing\nconst service = new OrderService(\n  new MockDatabase(),\n  new MockMailer()\n);\n```\n\n## DI Container (Simple)\n```javascript\nclass Container {\n  constructor() { this.services = {}; }\n  \n  register(name, factory) {\n    this.services[name] = factory;\n  }\n  \n  resolve(name) {\n    return this.services[name](this);\n  }\n}\n\nconst container = new Container();\ncontainer.register('db', () => new PostgresDatabase());\ncontainer.register('mailer', () => new SMTPMailer());\ncontainer.register('orderService', (c) => \n  new OrderService(c.resolve('db'), c.resolve('mailer'))\n);\n\nconst orderService = container.resolve('orderService');\n```", quiz: [{ question: "What is the main benefit of Dependency Injection?", options: ["Faster execution", "Dependencies are explicit, testable, and swappable", "Less code", "Better UI"], correctAnswer: 1, explanation: "DI makes dependencies explicit, allows easy testing with mocks, and enables swapping implementations without changing dependent code." }] };



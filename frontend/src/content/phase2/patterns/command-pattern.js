export const commandPattern = { title: "Command Pattern", duration: "15 minutes", content: "The Command pattern encapsulates a request as an object, allowing you to parameterize, queue, and undo operations.\n\n```javascript\nclass Command {\n  execute() { throw new Error('Not implemented'); }\n  undo() { throw new Error('Not implemented'); }\n}\n\nclass AddTextCommand extends Command {\n  constructor(editor, text, position) {\n    super();\n    this.editor = editor;\n    this.text = text;\n    this.position = position;\n  }\n  \n  execute() {\n    this.editor.insert(this.text, this.position);\n  }\n  \n  undo() {\n    this.editor.delete(this.position, this.text.length);\n  }\n}\n\nclass CommandHistory {\n  constructor() {\n    this.history = [];\n  }\n  \n  execute(command) {\n    command.execute();\n    this.history.push(command);\n  }\n  \n  undo() {\n    const command = this.history.pop();\n    if (command) command.undo();\n  }\n}\n```\n\n## Use Cases\n- Undo/Redo functionality\n- Transaction systems\n- Task queues\n- Macro recording", quiz: [{ question: "What makes Command pattern ideal for undo functionality?", options: ["It's faster", "Each command object knows how to reverse itself", "It uses less memory", "It's simpler"], correctAnswer: 1, explanation: "Command pattern encapsulates operations as objects with execute() and undo() methods, making it easy to reverse any operation." }] };



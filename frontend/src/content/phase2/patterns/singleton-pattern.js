export const singletonPattern = { title: "Singleton (& When Not to Use)", duration: "15 minutes", content: "The Singleton pattern ensures a class has only one instance. **Use it sparingly.**\n\n```javascript\nclass Logger {\n  static instance = null;\n  \n  constructor() {\n    if (Logger.instance) {\n      return Logger.instance;\n    }\n    this.logs = [];\n    Logger.instance = this;\n  }\n  \n  log(message) {\n    this.logs.push({ time: new Date(), message });\n    console.log(message);\n  }\n}\n\nconst logger1 = new Logger();\nconst logger2 = new Logger();\nconsole.log(logger1 === logger2); // true\n```\n\n## Problems with Singleton\n- **Global state**: Hard to test, hard to reason about\n- **Hidden dependencies**: Not clear what depends on what\n- **Tight coupling**: Hard to replace or mock\n\n## Better Alternative: Dependency Injection\n```javascript\n// Instead of Singleton, inject the instance\nclass Service {\n  constructor(logger) {\n    this.logger = logger; // Injected, can be mocked\n  }\n}\n```\n\n## When Singleton Might Be OK\n- Configuration objects (read-only)\n- Connection pools (carefully managed)\n- Caches (with clear invalidation)", quiz: [{ question: "Why is Singleton often considered problematic?", options: ["It's too slow", "It introduces global state and hidden dependencies", "It uses too much memory", "It's hard to implement"], correctAnswer: 1, explanation: "Singletons create global state, hide dependencies, and make testing difficult. Dependency injection is usually a better approach." }] };



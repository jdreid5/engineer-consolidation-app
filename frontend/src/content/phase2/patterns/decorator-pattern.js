export const decoratorPattern = { title: "Decorator Pattern", duration: "15 minutes", content: "The Decorator pattern attaches additional responsibilities to objects dynamically.\n\n```javascript\n// Base coffee\nclass Coffee {\n  cost() { return 5; }\n  description() { return 'Coffee'; }\n}\n\n// Decorators\nclass MilkDecorator {\n  constructor(coffee) { this.coffee = coffee; }\n  cost() { return this.coffee.cost() + 2; }\n  description() { return this.coffee.description() + ', Milk'; }\n}\n\nclass SugarDecorator {\n  constructor(coffee) { this.coffee = coffee; }\n  cost() { return this.coffee.cost() + 0.5; }\n  description() { return this.coffee.description() + ', Sugar'; }\n}\n\n// Usage - combine decorators\nlet order = new Coffee();\norder = new MilkDecorator(order);\norder = new SugarDecorator(order);\n\nconsole.log(order.description()); // Coffee, Milk, Sugar\nconsole.log(order.cost()); // 7.5\n```\n\n## Benefits\n- Add behavior without modifying original class\n- Combine multiple behaviors dynamically\n- Follow Open/Closed principle", quiz: [{ question: "How does the Decorator pattern add functionality?", options: ["By modifying the original class", "By wrapping objects with additional behavior", "By inheritance", "By using global variables"], correctAnswer: 1, explanation: "Decorators wrap objects, delegating to the wrapped object while adding their own behavior before or after." }] };



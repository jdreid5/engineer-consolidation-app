export const tddBasics = { title: "TDD Basics", duration: "20 minutes", content: "Test-Driven Development: Write tests BEFORE code.\n\n## The TDD Cycle: Red-Green-Refactor\n\n1. **Red**: Write a failing test\n2. **Green**: Write minimal code to pass\n3. **Refactor**: Clean up, keeping tests green\n\n## Example: Building a Calculator\n\n### Step 1: Red (Failing Test)\n```javascript\ntest('add returns sum of two numbers', () => {\n  const calc = new Calculator();\n  expect(calc.add(2, 3)).toBe(5);\n});\n// Fails: Calculator doesn't exist!\n```\n\n### Step 2: Green (Minimal Code)\n```javascript\nclass Calculator {\n  add(a, b) {\n    return 5; // Minimal to pass THIS test\n  }\n}\n```\n\n### Step 3: More Tests, Refactor\n```javascript\ntest('add works with negative numbers', () => {\n  expect(calc.add(-1, 1)).toBe(0);\n});\n\n// Now we need real implementation\nclass Calculator {\n  add(a, b) {\n    return a + b;\n  }\n}\n```\n\n## Benefits\n- Forces you to think about design first\n- Every line of code has a test\n- Confidence to refactor\n- Documentation through tests\n\n## When TDD Works Best\n- Clear requirements\n- Business logic\n- APIs with defined contracts\n- Bug fixes (write test that reproduces bug first)", quiz: [{ question: "In TDD, when do you write tests?", options: ["After the code is complete", "Before writing the implementation", "Only when bugs are found", "Only for critical code"], correctAnswer: 1, explanation: "In TDD, you write the test first (which fails), then write just enough code to make it pass, then refactor." }] };



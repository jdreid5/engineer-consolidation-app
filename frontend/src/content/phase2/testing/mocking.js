export const mocking = { title: "Mocking", duration: "20 minutes", content: "Mocks replace real dependencies with controlled test doubles.\n\n## Why Mock?\n- Isolate the code under test\n- Control behavior of dependencies\n- Avoid slow/flaky external calls\n- Test error scenarios\n\n## Types of Test Doubles\n\n### Stub: Returns canned data\n```javascript\nconst userRepository = {\n  findById: () => ({ id: 1, name: 'Test User' })\n};\n```\n\n### Mock: Records calls, verifies interactions\n```javascript\nconst emailService = {\n  sent: [],\n  send(to, subject) {\n    this.sent.push({ to, subject });\n  }\n};\n\n// After test\nexpect(emailService.sent).toHaveLength(1);\nexpect(emailService.sent[0].to).toBe('user@test.com');\n```\n\n### Jest Mocks\n```javascript\nconst mockFn = jest.fn();\nmockFn.mockReturnValue(42);\n\nmockFn();\nexpect(mockFn).toHaveBeenCalled();\nexpect(mockFn).toHaveReturnedWith(42);\n\n// Mock implementation\nmockFn.mockImplementation((x) => x * 2);\n```\n\n## Mocking Modules\n```javascript\njest.mock('./emailService', () => ({\n  send: jest.fn().mockResolvedValue(true)\n}));\n```", quiz: [{ question: "What is the difference between a stub and a mock?", options: ["Stubs are faster", "Stubs return data, mocks also verify interactions", "Mocks are for async code", "No difference"], correctAnswer: 1, explanation: "Stubs just return predetermined data. Mocks also record how they were called and let you verify those interactions." }] };


